The main challenge concerning the lab was getting the function call prologues and epilogues implemented in Assembly language as per the lecture directions. More than anything, managing the stack frame with the `ebp` and the `esp` without messing up the prologue and epilogue code became massive. On the other hand, ID'ing the correct way of pushing the argument onto the stack, from the point of view of the number, and then retrieving the argument from within the function `[ebp+8]` was a challenging issue for me as well. Furthermore, bearing in mind that the Linux system calls themselves need strings "Even" or "Odd" to print on the console, setting up the register assignments and syscall parameters had to be exact, otherwise the OS would simply crash or throw out no output at all. Debugging setups for such low-level details consumes too much time, as there won't be much in the way of feedback from the assembler on errors. However, by committing myself and strictly following step-by-step the lectureâ€™s example while testing every bit on compilation and execution on the JupyterHub terminal, I finally managed to implement the even or odd checking of a given number and print the corresponding result, which will cement my understanding about function
